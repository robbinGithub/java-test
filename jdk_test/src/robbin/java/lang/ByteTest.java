package robbin.java.lang;

/**
 * byte为什么要与上0xff？进行与int运算:
 * 
	举个简单的例子:
	byte[]  b = new byte[5];
	b[0] = -12;
	byte   8位二进制   =   1个字节    char   2个字节   short (2个字节)    int（4个字节） long（8个字节） float  （4个字节） double（8个字节）
	计算机存储数据机制：正数存储的二进制原码,负数存储的是二进制的补码。  补码是负数的绝对值反码加1。
	比如-12，-12 的绝对值原码是：0000 1100  取反： 1111 0011  加1：  1111 0100
	byte --> int   就是由8位变 32 位 高24位全部补1： 1111 1111 1111 1111 1111 1111 1111 0100 ;
	0xFF 是计算机十六进制的表示： 0x就是代表十六进制，A B C D E F  分别代表10 11 12 13 14 15   F就是15  一个F 代表4位二进制：可以看做 是   8  4  2  1。
	0xFF的二进制表示就是：1111 1111。   高24位补0：0000 0000 0000 0000 0000 0000 1111 1111;
	-12的补码与0xFF 进行与（&）操作  最后就是0000 0000 0000 0000 0000 0000 1111 0100 
	转换为十进制就是 244。
	byte类型的数字要&0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。
	
	当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性
	
 * @author robbin.zhang
 * @see http://blog.csdn.net/sinat_35767703/article/details/73089886
 */
public class ByteTest {
	
	/**
	 *  byte为什么要与上0xff？进行与int运算
	 */
	public void test_01(){
		
		
	}

}
