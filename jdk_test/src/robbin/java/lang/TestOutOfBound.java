package robbin.java.lang;

/**
 *  int和long都是很循规蹈矩的符合2的n次方的说法,int是32位，long是64位，唯有float和double像两个淘气的小孩子让人会捉摸不透。
 *  
 *  float和double的表示形式与int和long是不一样的，他们采用的是IEEE 754标准,这个标准可以这样理解:

	(1)两者还是32位的，和int一样,最小值只是他们的精度，是正数，这是需要注意的。如果要取到他们负最大，在他们的最大值前加个符号就好了,如-Float.MAX_VALUE,就是float能表示的负的最大了。
	
	(2)float从左到右，第一位是符号位,2-9位共8位表示整数位，2的8-1次方等于128,后面23位是表示小数的，所以最大值是2^128-1;
	
	(3)double从左到右，第一位是符号位，2-12是共11位表示整数位，2的11-1次方等于1024。剩余20位表示小数,所以最大值是2^1024-1.
	
	(4)如上面代码，当正的最大减去负的正最大，就产生了内存泄露。溢出的结果是不对的。

总结:int 和long，float和double的存储要分别对待.要取到实实在在的最大最小值，只需要取到最大值就行了。

	float：
	
	1bit（符号位） 8bits（指数位） 23bits（尾数位）
	
	double：
	
	1bit（符号位） 11bits（指数位） 52bits（尾数位）
	
	于是，float的指数范围为-128~+127，而double的指数范围为-1024~+1023，并且指数位是按补码的形式来划分的。

	其中负指数决定了浮点数所能表达的绝对值最小的非零数；而正指数决定了浮点数所能表达的绝对值最大的数，也即决定了浮点数的取值范围。
	
	float的范围为-2^128 ~ +2^127，也即-3.40E+38 ~ +3.40E+38；
	
	double的范围为-2^1024 ~ +2^1023，也即-1.79E+308 ~ +1.79E+308。
	
	
	基本类型	字节数	位数	最大值	最小值
	byte	1byte	8bit	2^7 - 1	-2^7    [-128-127]
	short	2byte	16bit	2^15 - 1	-2^15
	int	4byte	32bit	2^31 - 1	-2^31
	long	8byte	64bit	2^63 - 1	-2^63
	float	4byte	32bit	3.4028235E38	1.4E - 45
	double	8byte	64bit	1.7976931348623157E308	4.9E - 324
	char	2byte	16bit	2^16 - 1	0


     12.0f 的内存存储格式为：     0 1 0000010 10000000000000000000000     0.12 * 10 的2次方
     11.9f 的内存存储格式为:  0 1 0000010 011 11100110011001100110    0.119 * 10 的2次方


 * @author robbin.zhang
 * @see http://www.tuicool.com/articles/jUvyuu
 * @see http://www.cnblogs.com/chenfei0801/p/3672177.html
 * @see I http://blog.csdn.net/zcczcw/article/details/7362473
 *
 */
public class TestOutOfBound {
	
	public static void main(String[] args) { 
		
		
		System.out.println(Integer.MAX_VALUE-(-Integer.MAX_VALUE)); //内存溢出
		System.out.println(Integer.MAX_VALUE); //2的31次方-1,10个数位，正的20亿左右,用在钱上面不一定够
		System.out.println(Integer.MIN_VALUE); //负的2的31次方

		System.out.println(Long.MAX_VALUE); //2的64次方-1,19个数位，很大了,可放心用在钱上面
		System.out.println(Long.MIN_VALUE); //负的2的64次方

		System.out.println(Float.MAX_VALUE); //2的128次方-1, 38个数位，比long多了一倍,这个主要用来做简单数学精确运算使用
		System.out.println(Float.MIN_VALUE); //2的-149次方

		System.out.println(Double.MAX_VALUE); //2的1024次方-1, 308个数位，是float数位的10倍，主要用来做复杂运算和天文运算 
		System.out.println(Double.MIN_VALUE); //2的-1074次方 
		
		// 10000000
//		byte b = Byte.parseByte("10000000", 2);
//		System.out.println(b);
		
		
		// 1000000010010000000000000000000
		float f = 3.125f;
		System.out.println(Integer.toBinaryString(Float.floatToIntBits(f)));
		
		double d = 3.125;
		System.out.println(Long.toBinaryString(Double.doubleToLongBits(d)));
		
		
	/**	
	    将一个float型转化为内存存储格式的步骤为：
	     （1）先将这个实数的绝对值化为二进制格式。 
	     （2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。 
	     （3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。 
	     （4）如果实数是正的，则在第31位放入“0”，否则放入“1”。 
	     （5）如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。 
	     （6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。
	            如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。
	  @see http://blog.csdn.net/chencheng19912012/article/details/30072389
	 */   
		
//		8.25用二进制表示可表示为1000.01, 1*2的3次方+0*2的-1次方+1*2的-2次方
//		120.5用二进制表示为：1110110.1     
		
//		8.25，用二进制的科学计数法表示为:1.0001*2(3次方)
//		0 10000010 00010000000000000000000
		
//		120.5用二进制科学计数法表示：1110110.1  ==> 1110110.1 ==> 1.1101101 * 2 (6)
//		0 1 10000101 11011010000000000000000
		
		
/*		01000001000001000000000000000000
		01000010111100010000000000000000*/
//		@see http://blog.csdn.net/longshenlmj/article/details/47616481
		System.out.println(Integer.toBinaryString(Float.floatToIntBits(8.25f)));
		System.out.println(Integer.toBinaryString(Float.floatToIntBits(120.5f)));
		
		// http://blog.csdn.net/qiantudou/article/details/49928423
		byte tByte = -5;  
		String tString = Integer.toBinaryString((tByte & 0xFF) + 0x100).substring(1); 
		System.out.println(tString); 
		
		// -1      11111111
		// -2      11111110
		// -128    10000000    
		// -5      11111011    00000101     取反 11111010 + 1 ==>11111011
		
		// 5+127   132
		System.out.println(Integer.toBinaryString(127)); // 01111111
		System.out.println(Integer.toBinaryString(132)); // 10000100
		
		
		/*
		例2. -12.5(10)转为 float 型

		  1. 符号位 位1， 阶码8位， 尾数 23位

		            12.5=12+0.5= 1100.1 (2)

		             小数点左移3位， 即为  1.1001. 去掉最高位1， 尾数部分为 1001

		   2.   小数点左移量为3； float阶码位数为8，即偏移量修正值为2^(8-1)-1=127;

		              3+127=130(10) --->82(16) ---> 1000 0010(2)

		  3. 负数，符号位为1

		  4. 符号位+阶码+尾数，最终结果为 1 1000 0010 1001 0000 0000 0000 000
		  
		  */
		
	/*	
		例1. 38414.4（10）转为double型

	      1. 符号位为0，价码11位， 尾数52位

               38414.4=38414.4+0.4 ；

               38414（10）= 960E （16）= 1001 0110 0000 1110 (2)； 0.4(10) =0.5×0+0.25×1+0.125x1+0.0625x0+0.03125x0...= 0.0110 ... // 此处无法除尽，要算满36位，                                                                                                                                                                                                                           以补足加上整数部分后，整个尾数部分要有52位

               38414.4(10)= 1001 0110 0000 1110 . 0110 ....（2）

	                              小数点左移15位即为 1. 001 0110 0000 1110 0110...   x 2的15次方,去掉最高为的1后，尾数 001 0110 0000 0110 ...

	      2.  小数点左移量为15； double的阶码位数为11位，即偏移量修正值为 2^(11-1)-1=1023；

	           15+1023=1038（10）---->  40E（16）---->0100 0000 1110 (2)

	       3. 正数 ，不需要扩展

	       4. 阶码+尾数，最终结果   即为double 型  0100  0000 1110  001 0110 0000 0110.... (尾数部分的小数要算满到补足尾数的52位)*/
		
		/**
		 *  举例说明： 11.9的内存存储格式(左移)
	       (1) 将11.9化为二进制后大约是" 1011. 1110011001100110011001100..."。
	       (2) 将小数点左移三位到第一个有效位右侧： "1. 011 11100110011001100110 "。 保证有效位数24位，右侧多余的截取（误差在这里产生了 ）。
	       (3) 这已经有了二十四位有效数字，将最左边一位“1”去掉，得到“ 011 11100110011001100110 ”共23bit。将它放入float存储结构的第22到第0位。
	       (4) 因为11.9是正数，因此在第31位实数符号位放入“0”。
	       (5) 由于我们把小数点左移，因此在第30位指数符号位放入“1”。
	       (6) 因为我们是把小数点左移3位，因此将3减去1得2，化为二进制，并补足7位得到0000010，放入第29到第23位。
		 */
		/*
         * 1.转换成二进制:1011.1110011001100110011001100...		
         * 2.转换成二进制科学计数法：1.111000101000001001 * 2(-3)
         * 3.0
         *   0 
         *   0000011 ->取反 1111100    
         *   11100010100000100100000 (23)
         *   
         *   => 0 01111100 11100010100000100100000
         */
		
		/**
		 * 分析小数：0.2356 (右移)
		 * （1）将0.2356化为二进制后大约是0.00111100010100000100100000。 
		       （2）将小数点右移三位得到1.11100010100000100100000。 
		       （3）从小数点右边数出二十三位有效数字，即11100010100000100100000放入第22到第0位。 
		      （4）由于0.2356是正的，所以在第31位放入“0”。 
		      （5）由于我们把小数点右移了，所以在第30位放入“0”。 
		      （6）因为小数点被右移了3位，所以将3化为二进制，在左边补“0”补足七位，得到0000011，各位取反，得到1111100，放入第29到第23位。 
		 */
		
		// @see http://blog.csdn.net/sinat_35767703/article/details/73089886
	}
//	-2
//	2147483647
//	-2147483648
//	9223372036854775807
//	-9223372036854775808
//	3.4028235E38
//	1.4E-45
//	1.7976931348623157E308
//	4.9E-324
	 

}
